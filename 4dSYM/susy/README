# ------------------------------------------------------------------
Four-dimensional N=4 supersymmetric Yang--Mills theory

# Actively maintained targets:
susy_hmc for evolution with accept/reject step
susy_meas for standard measurements on saved configurations
susy_hmc_meas for evolution along with standard measurements
susy_eig for eigenvalue measurements on saved configurations
susy_phase for pfaffian phase measurements on saved configurations

# Additional targets, not actively maintained or regularly tested
susy_phi for evolution without accept/reject step
susy_hmc_pg and susy_phi_pg for testing with gauge fields only (no fermions)
susy_spill for printing out configuration in format expected by serial C++ code

# Dependences:
Measurements involving polar-projected matrices (susy_meas and susy_hmc_meas) require LAPACK
Eigenvalue measurements (susy_eig) require PRIMME and LAPACK -- PRIMME can be obtained from http://www.cs.wm.edu/~andreas/software/

# Defines for compilation:
-DPHI_ALGORITHM for the basic phi algorithm (REQUIRED)
-DHMC_ALGORITHM switches on the accept/reject step
-DCORR switches on the Konishi and SUGRA correlator calculation
-DSTOUT switches on stout smearing for measurements
-DWLOOP switches on the gauge-fixed Wilson loop calculation
-DBILIN switches on the fermion bilinear calculation
-DEIG switches on the PRIMME eigenvalue calculation
-DPL_CORR switches on the Polyakov loop correlator calculation (NOT CURRENTLY IN USE)
-DPUREGAUGE switches off the fermions (FOR TESTING)

# Gauge group and fermion rep:
NCOL and DIMF defined in ../include/su3.h
For now we fix U(NCOL) gauge group with DIMF=NCOL*NCOL for adjoint rep

# Boundary conditions for fermions:
Only supports periodic spatial boundary conditions for now
PBC = +/-1 chooses periodic or anti-periodic temporal boundary conditions, defined in defines.h
# ------------------------------------------------------------------



# ------------------------------------------------------------------
# Input parameters for the action:
lambda   -- 't Hooft coupling, used to set kappa=NCOL/(2lambda) in setup.c
bmass    -- bosonic mass
fmass    -- fermion mass, the RHMC uses D^dag D + fmass^2
kappa_u1 -- plaquette determinant coupling

# Sample input file with explanations:
prompt 0              # 0 (1) to read in parameters without (with) prompts
nx 6                  # Lattice volume
ny 6
nz 6
nt 6
iseed 41              # Random number generator seed

warms 0               # Number of trajectories without measurements
trajecs 10            # Number of trajectories with measurements
traj_length 1         # Trajectory length
nstep 10              # Fermion steps per trajectory; step_size = traj_length / nstep
nstep_gauge 10        # Gauge steps per fermion step
traj_between_meas 1   # How many trajectories to skip between less-frequent measurements

lambda 1.5            # 't Hooft coupling
kappa_u1 0.6          # Plaquette determinant coupling
bmass 0.2             # Bosonic mass parameter (mu)
fmass 0.0             # Mass shift in fermion operator

Nstout 1              # Number of stout smearing steps -- only include with -DSTOUT
rho 0.1               # Stout smearing parameter -- only include with -DSTOUT

max_cg_iterations 500 # Maximum number of CG iterations
error_per_site 1e-5   # Stopping condition for CG (will be squared)
nsrc 5                # Number of stochastic sources -- only include with -DBILIN

Nvec 100              # Number of eigenvalues to calculate -- only include with -DEIG
eig_tol 1e-8          # Eigenvalue convergence criterion -- only include with -DEIG
maxIter 5000          # Maximum number of eigenvalue iterations -- only include with -DEIG

                      # Checkpointed pfaffian I/O currently hard-codes the file names to save and load,
                      # based on the following two parameters
ckpt_load -1          # If positive, load all subsequent columns of Q from dumped files -- only include with -DPHASE
ckpt_save -1          # If positive, dump all subsequent columns of Q -- only include with -DPHASE

fresh                 # What to do with lattice at start: only fresh, random, continue or reload_serial
coulomb_gauge_fix     # Only coulomb_gauge_fix and no_gauge_fix supported
forget                # What to do with lattice at end: only forget or save_serial
# ------------------------------------------------------------------



# ------------------------------------------------------------------
# 0) Header files in this directory:
defines.h       -- Defines Omelyan parameters, RHMC degree, temporal boundary conditions, and numbers of links, generators, offsets and terms in the action
lattice.h       -- Defines Twist_Fermions, the site struct, global variables and fields
params.h        -- Defines a struct for reading input parameters
primme.h        -- Defines for PRIMME eigenvalue calculations
susy_includes.h -- Defines lots of routines, some of which are discussed below

# 1) Routines in this directory:
# 1a) Files used by all executables
setup.c               -- Reads in parameters, initializes variables
setup_lambda.c        -- Sets up U(N) generators, epsilon symbols and lookup tables for nested loops
setup_offset.c        -- Sets up gathers for terms in the action, including Qclosed terms
d_action.c            -- Computes action
congrad_multi_field.c -- Multi-mass CG
fermion_rep.c         -- Creates links in adjoint rep, checking dimensions
grsource.c            -- Gaussian random numbers for gauge momenta
library_util.c        -- Various routines that might be better suited to ../libraries/
utilities.c           -- Many basic routines associated with parts of the action
d_link.c              -- Computes average link
determinant.c         -- Utilities for finding determinants
gauge_info.c          -- Puts information into configuration files

# 1b) Evolution-specific files
control.c     -- Main program for evolution and measurements
det_force.c   -- Contribution to force from determinant term
setup_rhmc.c  -- Initializes RHMC shifts and amplitudes, values copied from ./remez-milc output
update_o.c    -- Omelyan HMC evolution, includes ranmom() routine
update_h.c    -- Updates gauge momenta

# 1c) Measurement-specific files
control_meas.c        -- Main program for standard measurements only
control_eig.c         -- Main program for eigenvalues measurements only
d_bilinear.c          -- Fermion bilinear and susy transformation calculation
d_correlator.c        -- Konishi and SUGRA correlators C(t) (zero momentum projected)
d_correlator_r.c      -- Konishi and SUGRA correlators C(r)
hvy_pot.c             -- Computes correlators of gauge-fixed timelike links
hvy_pot_polar.c       -- Computes correlators of polar-projected gauge-fixed timelike links
                         (NB: overwrites links, which have to be saved and restored if they will be used further)
hvy_pot_loop.c        -- Computes more standard Wilson loops
hvy_pot_polar_loop.c  -- Computes more standard Wilson loops of polar-projected links
                         (NB: overwrites links, as above)
path.c                -- Used to construct Wilson loops for hvy_pot_loop.c and hvy_pot_polar_loop.c
rsymm.c               -- Modified Wilson loops related to R symmetry transformations
eig.c                 -- Eigenvalue measurements using PRIMME
                         Must specify path to libzprimme.a as PLIB in makefile
                         Also need LAPACK and BLAS in linkable location
d_phase.c             -- Phase and (log of) magnitude of the pfaffian

# 1d) Files not currently used, retained for potential future testing
ploop_corr.c      -- Finds Polyakov loop on every site for correlations with FFT done in control.c
print_var3.c      -- Prints out results on a 3d lattice (used with ploop_corr)
update_leapfrog.c -- Leapfrog HMC evolution, includes ranmom() routine

# 2) Routines in the ../generic directory:
# 2a) Files used by all executables
com_vanilla.c           -- Serial communications, selected by Makefile
com_mpi.c               -- Parallel communications, selected by Makefile
d_plaq4.c               -- Calculates the plaquette (both fundamental and irrep)
ploop_dist.c            -- Computes average Polyakov loop
io_lat.c                -- I/O modified to handle five-link lattice
io_lat_utils.c          -- Lower-level utilities for lattice I/O
io_helpers.c            -- More I/O, seems to include the interface
make_lattice.c          -- Set up lattice, neighbors, etc.
nersc_cksum.c           -- Compute link trace sum for lattice I/O (cksum itself set to zero)
ranstuff.c              -- Random number stuff, both for serial and parallel running
remap_stdio_from_args.c -- For reading input parameters
layout_hyper_prime.c    -- Layout lattice on processors
stout.c                 -- Stout smearing on A4* lattice

# 2b) Measurement-specific files
gaugefix.c          -- Fixes to Coulomb gauge (requires even number of sites in all directions)
restrict_fourier.c  -- Fast Fourier transform routine only used with -DPL_CORR
d_plaq4_lcl.c       -- Calculates the plaquette with options to print more info
                       Used to monitor minimum plaquette when smearing with -DSTOUT
io_phase.c          -- Primitive (for now) dump and load routines for checkpointing pfaffian computations
# ------------------------------------------------------------------



# ------------------------------------------------------------------
# Action:
# According to d_action.c, the bosonic action is g_act + bmass_act + det_act + h_act

# h_act:
# This is the gauge momenta contribution to the action, from d_hmom_action()
  double sum = 0;
  for (mu = 0; mu < NUMLINK; mu++) {
    FORALLSITES(i, s)
      sum += (double)realtrace_su3_f(&(s->mom[mu]), &(s->mom[mu]));
  }
  g_doublesum(&sum);

# g_act:
# This is the gauge action itself, from d_gauge_action().  Note the factor of kappa
# We include a tunable parameter in the DmuUmu^2 term, norm=0.5C_2
  double g_action = 0;
  compute_DmuUmu();
  FORALLSITES(i, s) {
    mult_su3_nn_f(&(s->DmuUmu), &(s->DmuUmu), &tmpmat);
    cg_action = trace_su3_f(&tmpmat);
    g_action += norm * cg_action.real;
  }

  compute_Fmunu();
  for (mu = 0; mu < NUMLINK; mu++) {
    for (nu = mu + 1; nu < NUMLINK; nu++) {
      FORALLSITES(i, s)
        g_action += 2 * realtrace_su3_f(&(s->Fmunu[mu][nu]),
                                        &(s->Fmunu[mu][nu]));
    }
  }
  g_action *= kappa;
  g_doublesum(&g_action);

# bmass_act:
# This is the mass term for the U(1) mode, from d_bmass_action().  Note the factor of kappa
  double sum = 0;
  for (mu = 0; mu < NUMLINK; mu++) {
    FORALLSITES(i, s) {
      dum = (1 / (double)NCOL) * realtrace_su3_f(&(s->linkf[mu]), &(s->linkf[mu])) - 1.0;
      sum += kappa * bmass * bmass * dum * dum;
    }
  }
  g_doublesum(&sum);

# det_act:
# This is the squared determinant term, from d_det_action().  Note no factor of kappa
  double det_action = 0.0;
  for (dir1 =1; dir1 < NUMLINK; dir1++) {
    for (dir2 =0; dir2 < dir1; dir2++) {
      (...omit construction of plaquette in tmat...)
      FORALLSITES(i, s) {
        det = find_det(&tmat);
        det_action += (double)((det.real - 1.0) * (det.real - 1.0) + det.imag * det.imag);
      }
    }
  }
  det_action *= kappa_u1;
  g_doublesum(&det_action);
# ------------------------------------------------------------------
